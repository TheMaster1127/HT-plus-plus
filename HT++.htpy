; HT++

isVarAnumKindaVar(strrrrr)
{

strLettersStart := 48
Loop, 10
{
if (InStr(strrrrr, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}

return false
}

varDetect(strrrrr)
{

if (InStr(strrrrr, "-"))
{
return false
}

numFixhsidhkcjzdls := 0
Loop, Parse, strrrrr
{
numFixhsidhkcjzdls++
}
numFixhsidhkcjzdls22 := 0
Loop, Parse, strrrrr
{
if (A_LoopField = Chr(48)) or (A_LoopField = Chr(49)) or (A_LoopField = Chr(50)) or (A_LoopField = Chr(51)) or (A_LoopField = Chr(52)) or (A_LoopField = Chr(53)) or (A_LoopField = Chr(54)) or (A_LoopField = Chr(55)) or (A_LoopField = Chr(56)) or (A_LoopField = Chr(57)) or (A_LoopField = Chr(46))
{
numFixhsidhkcjzdls22++
}
}

if (numFixhsidhkcjzdls = numFixhsidhkcjzdls22)
{
return false
}

strLettersStart := 97
Loop, 26
{
if (InStr(strrrrr, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}


strLettersStart := 65
Loop, 26
{
if (InStr(strrrrr, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}


strLettersStart := 48
Loop, 10
{
if (InStr(strrrrr, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}

if (InStr(strrrrr, Chr(95)))
{
return true
}

if (InStr(strrrrr, Chr(37)))
{
return true
}

return false
}


isVarAfuncOrWhat(varInVarTranspiler, funcNames, allVarsChars, allVarsInts)
{

if (InStr(varInVarTranspiler, "%"))
{

nameOfVarr11 := Trim(StrSplit(varInVarTranspiler, "%", 1))
nameOfVarr12 := Trim(StrSplit(varInVarTranspiler, "%", 2))
nameOfVarr111 := "variables[" . Chr(34) . nameOfVarr11 . Chr(34) . " + std::string(variables[" . Chr(34) . nameOfVarr12 . Chr(34) . "])]"

return nameOfVarr111
}

Loop, Parse, allVarsChars, `n ,`r
{
if (Trim(varInVarTranspiler) = Trim(A_LoopField))
{
return varInVarTranspiler
}
}

Loop, Parse, allVarsInts, `n ,`r
{
if (Trim(varInVarTranspiler) = Trim(A_LoopField))
{
return varInVarTranspiler
}
}

Loop, Parse, funcNames, "|"
{

if (varInVarTranspiler = A_LoopField)
{
return varInVarTranspiler
}


if (InStr(Trim(varInVarTranspiler), A_LoopField . "("))
{
return varInVarTranspiler
}


}



if (SubStr(varInVarTranspiler, 1, 1) = "[")
{
StringTrimLeft, varInVarTranspiler, varInVarTranspiler, 1
StringTrimRight, varInVarTranspiler, varInVarTranspiler, 1
return "variables[" . Chr(34) . varInVarTranspiler . Chr(34) . "]"
}

if (varDetect(varInVarTranspiler))
{
return varInVarTranspiler
}

if (isVarAnumKindaVar(varInVarTranspiler))
{
return varInVarTranspiler
}


if (varInVarTranspiler = ".")
{
return "+"
}

if (varInVarTranspiler = "=")
{
return "=="
}



if (varInVarTranspiler = "or")
{
return "||"
}

if (varInVarTranspiler = "and")
{
return "&&"
}



return varInVarTranspiler

}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

varTranspiler(var123, funcNames, allVarsChars, allVarsInts)
{
var123out := ""

lastType := ""
typeMode := 0

var123 := StrReplace(var123, ",", " , ")
var123 := StrReplace(var123, "(", " ( ")
var123 := StrReplace(var123, ")", " ) ")


Loop, Parse, var123, " "
{

if (A_LoopField = "int") or (A_LoopField = "str")
{
typeMode := 1
lastType := Trim(A_LoopField)
}
if (A_LoopField != "int") and (A_LoopField != "str") and (typeMode = 1)
{

varInVarTranspiler := Trim(A_LoopField)
varOut2out := isVarAfuncOrWhat(varInVarTranspiler, funcNames, allVarsChars, allVarsInts)

if (lastType = "int")
{
varOut2out := "INT(" . varOut2out . ")"
}
if (lastType = "str")
{
varOut2out := "std::string(" . varOut2out . ")"
}

var123out .= str(varOut2out) . " "

typeMode := 0
}
else if (A_LoopField != "int") and (A_LoopField != "str") and (typeMode = 0)
{
varInVarTranspiler := Trim(A_LoopField)
varOut2out := isVarAfuncOrWhat(varInVarTranspiler, funcNames, allVarsChars, allVarsInts)

var123out .= str(varOut2out) . " "
}


}

StringTrimRight, var123out, var123out, 1
return var123out
} ; end of func





CheckIFandElsesss1 := "if ("
CheckIFandElsesss2 := "if("
CheckIFandElsesss3 := "if !("
CheckIFandElsesss4 := "if!("
CheckIFandElsesss5 := "else if ("
CheckIFandElsesss6 := "else if("
CheckIFandElsesss7 := "else if !("
CheckIFandElsesss8 := "else if!("
CheckIFandElsesssNum := 0
onceImportTime := 0
weUseRandomAtLeastOnce := 0
weEverUseVars := ""
haveWeEverUsedAloop := 0
usedLib := ""
putEndPointFlask1Up := ""
putEndPointFlask2Down := ""
AindexcharLength := 1
pycodeAcurlyBraceAddSomeVrasFixNL := 0
pycodeAcurlyBraceAddSomeVrasFixLP := 0
pycodeLoopfixa := ""
out := ""
HTpyCodeD1 := ""
skipLeftCuleyForFuncPLS := 0
eavbnsalvbaslv := 0
theMainFuncDec := 0
upCode := ""
removeNextCurlyBraceCpp := 0

params := GetParams()
Loop, Parse, params, `n, `r
{
if (A_Index = 1)
{
MsgBox, % A_LoopField
filePathOfCode := A_LoopField
;code := FileRead(filePathOfCode)
FileRead, code, %filePathOfCode%

}
if (A_Index = 2)
{
MsgBox, % A_LoopField
}
}
;MsgBox, % code

nothing := ""
code := StrReplace(code, Chr(13), nothing)

codeTrimBeggining := ""
Loop, Parse, code, `n, `r
{
codeTrimBeggining .= Trim(A_LoopField) . "`n"
}
StringTrimRight, code, codeTrimBeggining, 1


HTpyCodeOUT754754 := ""
areWEinSome34sNum := 0
theIdNumOfThe34 := 0

Loop, Parse, code
{
theIdNumOfThe34theVar%A_Index% := Chr(34)
}

Loop, Parse, code
{
if (A_LoopField = Chr(34))
{
areWEinSome34sNum++
}


if (areWEinSome34sNum = 1)
{



if (A_LoopField != Chr(34))
{
if (A_LoopField = Chr(96))
{
theIdNumOfThe34theVar%theIdNumOfThe34% .= Chr(92)
}
else
{
theIdNumOfThe34theVar%theIdNumOfThe34% .= A_LoopField
}
}
else
{
theIdNumOfThe34++
HTpyCodeOUT754754 .= "ihuiuuhuuhtheidFor--asas-theuhturtyphoutr-" . Chr(65) . Chr(65) . str(theIdNumOfThe34) . Chr(65) . Chr(65)
}

}


if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0)
{
if (A_LoopField != Chr(34))
{
HTpyCodeOUT754754 .= A_LoopField
}

areWEinSome34sNum := 0
}



}
code := HTpyCodeOUT754754

Loop, % theIdNumOfThe34
{
theIdNumOfThe34theVar%A_Index% .= Chr(34)
}

allVarsChars := ""
allVarsInts := ""
funcNames := "std::string|InStr|LoopParseFunc|print|FileRead|FileAppend|FileDelete|SubStr|Trim|StrReplace|StringTrimLeft|StringTrimRight|StrLower|RegExReplace|StrSplit|Chr|Mod|Floor|A_TickCount|STR|INT|FLOAT"

; func
Loop, Parse, code, `n, `r
{
if (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = "func ")
{
StringTrimLeft, funcName123, A_LoopField, 5
funcName123 := Trim(StrSplit(funcName123, "(", 1))
funcNames .= "|" . funcName123
}
}




cppCode := ""
Loop, Parse, code, `n, `r
{

lineDone := 0
if (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = "msgbox, % ")
{
StringTrimLeft, msgboxCode, A_LoopField, 10

msgboxCode := varTranspiler(msgboxCode, funcNames, allVarsChars, allVarsInts)

cppCode .= "print(" . msgboxCode . ");" . "`n"
lineDone := 1
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = "msgbox, ")
{
StringTrimLeft, msgboxCode, A_LoopField, 8



cppCode .= "print(std::string(" . Chr(34) . msgboxCode . Chr(34) . "));" . "`n"
lineDone := 1
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = ";")
{
StringTrimLeft, str1234, A_LoopField, 1
cppCode .= "//" . str1234 . "`n"
lineDone := 1
}
else if (SubStr(A_LoopField, -1) = "++")
{
str123 := Trim(A_LoopField)
StringTrimRight, str123, str123, 2

out := str123 . "++;"
cppCode .= out . "`n"
lineDone := 1
}
else if (SubStr(A_LoopField, -1) = "--")
{
str123 := Trim(A_LoopField)
StringTrimRight, str123, str123, 2

out := str123 . "--;"
cppCode .= out . "`n"
lineDone := 1
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = "fileread, ")
{
StringTrimLeft, filereadCommand, A_LoopField, 10
filereadCommand1varname := StrSplit(filereadCommand, ", ", 1)
filereadCommand2path := StrSplit(filereadCommand, ", ", 2)

filereadCommand2path := StrReplace(filereadCommand2path, "\\", "\\\\")

filereadCommand2path := Trim(transpileLowVariables(filereadCommand2path))
filereadCommand1varname := Trim(transpileVariables(filereadCommand1varname, functionNames))
cppCode .= filereadCommand1varname . " = FileRead(" . filereadCommand2path . ")`n"
lineDone := 1
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 12) = "fileappend, ")
{
StringTrimLeft, fileAppendCommand, A_LoopField, 12
fileAppendCommand1varname := StrSplit(fileAppendCommand, ", ", 1)
fileAppendCommand2path := StrSplit(fileAppendCommand, ", ", 2)

fileAppendCommand2path := StrReplace(fileAppendCommand2path, "\\", "\\\\")

fileAppendCommand1varname := Trim(transpileLowVariables(fileAppendCommand1varname))
fileAppendCommand2path := Trim(transpileLowVariables(fileAppendCommand2path))

cppCode .= "FileAppend(" . fileAppendCommand1varname . ", " . fileAppendCommand2path . ")`n"
lineDone := 1
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 12) = "filedelete, ")
{
StringTrimLeft, fileDeleteCommand, A_LoopField, 12

fileDeleteCommand2path := StrSplit(fileDeleteCommand, ", ", 1)

fileDeleteCommand2path := StrReplace(fileDeleteCommand2path, "\\", "\\\\")
fileDeleteCommand2path := Trim(transpileLowVariables(fileDeleteCommand2path))


cppCode .= "FileDelete(" . fileDeleteCommand2path . ")`n"
lineDone := 1
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 17) = StrLower("StringTrimRight, "))
{
varr1 := StrSplit(A_LoopField, ",", 2)
varr2 := StrSplit(A_LoopField, ",", 3)
varr3 := StrSplit(A_LoopField, ",", 4)

outt1 := Trim(varTranspiler(varr1, funcNames, allVarsChars, allVarsInts))
outt2 := Trim(varTranspiler(varr2, funcNames, allVarsChars, allVarsInts))
outt3 := Trim(varTranspiler(varr3, funcNames, allVarsChars, allVarsInts))

out := outt1 . " = " . "StringTrimRight(" . outt2 . ", " . outt3 . ");"

cppCode .= out . "`n"
lineDone := 1
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 16) = StrLower("StringTrimLeft, "))
{
varr1 := StrSplit(A_LoopField, ",", 2)
varr2 := StrSplit(A_LoopField, ",", 3)
varr3 := StrSplit(A_LoopField, ",", 4)

outt1 := Trim(varTranspiler(varr1, funcNames, allVarsChars, allVarsInts))
outt2 := Trim(varTranspiler(varr2, funcNames, allVarsChars, allVarsInts))
outt3 := Trim(varTranspiler(varr3, funcNames, allVarsChars, allVarsInts))

out := outt1 . " = " . "StringTrimLeft(" . outt2 . ", " . outt3 . ");"

cppCode .= out . "`n"
lineDone := 1
}
else if (A_LoopField = "main:")
{
theMainFuncDec := 1
cppCode .= "`nint main()`n{`n"
lineDone := 1
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = "func ")
{
StringTrimLeft, funcName123, A_LoopField, 5

removeNextCurlyBraceCpp := 1
funcName123 := StrReplace(funcName123, " str ", " std::string ")
funcName123 := StrReplace(funcName123, "(str ", "std::string ")
cppCode .= "std::any " . funcName123 . "`n{`n"
lineDone := 1
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = "str ")
{
StringTrimLeft, strVar, A_LoopField, 4
strVar := Trim(strVar)


declareAvarNOvalue := 0
if (InStr(strVar, " := "))
{
varAssignmentType := "="
}
else if (InStr(strVar, " += "))
{
varAssignmentType := "+="
}
else if (InStr(strVar, " .= "))
{
varAssignmentType := "+="
}
else if (InStr(strVar, " -= "))
{
varAssignmentType := "-="
}
else if (InStr(strVar, " *= "))
{
varAssignmentType := "*="
}
else if (InStr(strVar, " /= "))
{
varAssignmentType := "/="
}
else
{
declareAvarNOvalue := 1
}

if (declareAvarNOvalue = 1)
{
nameOfVar1 := Trim(StrSplit(strVar, " ", 1))
nameOfVarSplit := StrSplit(strVar, " ", 2)
nameOfVar2 := Trim(StrSplit(strVar, str(nameOfVarSplit), 2))
nameOfVar2 := varTranspiler(nameOfVar2, funcNames, allVarsChars, allVarsInts)

cppCode .= "std::string " . nameOfVar1  . Chr(59) . "`n"
}
else
{
nameOfVar1 := Trim(StrSplit(strVar, " ", 1))
nameOfVarSplit := StrSplit(strVar, " ", 2)
nameOfVar2 := Trim(StrSplit(strVar, str(nameOfVarSplit), 2))
nameOfVar2 := varTranspiler(nameOfVar2, funcNames, allVarsChars, allVarsInts)

cppCode .= "std::string " . nameOfVar1  . " " . varAssignmentType . " " . nameOfVar2 . Chr(59) . "`n"
}
lineDone := 1


}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = "[")
{
StringTrimLeft, strVar, A_LoopField, 1
strVar := Trim(strVar)

declareAvarNOvalue := 0
if (InStr(strVar, " := "))
{
varAssignmentType := "="
}
else if (InStr(strVar, " += "))
{
varAssignmentType := "+="
}
else if (InStr(strVar, " .= "))
{
varAssignmentType := "+="
}
else if (InStr(strVar, " -= "))
{
varAssignmentType := "-="
}
else if (InStr(strVar, " *= "))
{
varAssignmentType := "*="
}
else if (InStr(strVar, " /= "))
{
varAssignmentType := "/="
}
else
{
declareAvarNOvalue := 1
}


if (declareAvarNOvalue = 1)
{
nameOfVar1 := Trim(StrSplit(strVar, " ", 1))
StringTrimRight, nameOfVar1, nameOfVar1, 1

nameOfVarSplit := StrSplit(strVar, " ", 2)
nameOfVar2 := Trim(StrSplit(strVar, str(nameOfVarSplit), 2))
nameOfVar2 := varTranspiler(nameOfVar2, funcNames, allVarsChars, allVarsInts)

cppCode .= "variables[" . Chr(34) . nameOfVar1 . Chr(34) . "]" . Chr(59) . "`n"
}
else
{
nameOfVar1 := Trim(StrSplit(strVar, " ", 1))
StringTrimRight, nameOfVar1, nameOfVar1, 1

nameOfVarSplit := StrSplit(strVar, " ", 2)
nameOfVar2 := Trim(StrSplit(strVar, str(nameOfVarSplit), 2))
nameOfVar2 := varTranspiler(nameOfVar2, funcNames, allVarsChars, allVarsInts)

cppCode .= "variables[" . Chr(34) . nameOfVar1 . Chr(34) . "] " . varAssignmentType . " " . nameOfVar2 . Chr(59) . "`n"
}

lineDone := 1
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = "char ")
{
StringTrimLeft, varName123Temp, A_LoopField, 5
varName := StrSplit(varName123Temp, " ", 1)
lineDone := 1


StringTrimLeft, strVar, A_LoopField, 5
strVar := Trim(strVar)

declareAvarNOvalue := 0
if (InStr(strVar, " := "))
{
varAssignmentType := "="
}
else if (InStr(strVar, " += "))
{
varAssignmentType := "+="
}
else if (InStr(strVar, " .= "))
{
varAssignmentType := "+="
}
else if (InStr(strVar, " -= "))
{
varAssignmentType := "-="
}
else if (InStr(strVar, " *= "))
{
varAssignmentType := "*="
}
else if (InStr(strVar, " /= "))
{
varAssignmentType := "/="
}
else
{
declareAvarNOvalue := 1
}

if (declareAvarNOvalue = 1)
{
charVar1 := Trim(StrSplit(strVar, ":=", 1))


didItFoundTheChar := 0

cppCode .= "const char* " . charVar1 . Chr(59) . "`n"
}
else
{

charVar1 := Trim(StrSplit(strVar, ":=", 1))
charVar2 := Trim(StrSplit(strVar, ":=", 2))

didItFoundTheChar := 0

cppCode .= "const char* " . charVar1 . " " . varAssignmentType . " " . charVar2 . Chr(59) . "`n"
}

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = "int ") or (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = "int8 ") or (SubStr(Trim(StrLower(A_LoopField)), 1, 6) = "int16 ") or (SubStr(Trim(StrLower(A_LoopField)), 1, 6) = "int32 ")
{
lineDone := 1
if (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = "int8 ")
{
StringTrimLeft, varName123Temp, A_LoopField, 5
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = "int ")
{
StringTrimLeft, varName123Temp, A_LoopField, 4
}
else
{
StringTrimLeft, varName123Temp, A_LoopField, 6
}

intType := Trim(StrSplit(A_LoopField, " ", 1)) . "_t"


varName := StrSplit(varName123Temp, " ", 1)

allVarsInts .= varName . "`n"

if (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = "int8 ")
{
StringTrimLeft, strVar, A_LoopField, 5
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = "int ")
{
StringTrimLeft, strVar, A_LoopField, 4
}
else
{
StringTrimLeft, strVar, A_LoopField, 6
}
strVar := Trim(strVar)

declareAvarNOvalue := 0
if (InStr(strVar, " := "))
{
varAssignmentType := "="
}
else if (InStr(strVar, " += "))
{
varAssignmentType := "+="
}
else if (InStr(strVar, " .= "))
{
varAssignmentType := "+="
}
else if (InStr(strVar, " -= "))
{
varAssignmentType := "-="
}
else if (InStr(strVar, " *= "))
{
varAssignmentType := "*="
}
else if (InStr(strVar, " /= "))
{
varAssignmentType := "/="
}
else
{
declareAvarNOvalue := 1
}

if (declareAvarNOvalue = 1)
{
charVar1 := Trim(StrSplit(strVar, varAssignmentType, 1))
charVar2 := Trim(StrSplit(strVar, varAssignmentType, 2))
charVar1 := StrSplit(charVar1, " ", 1)


charVar2 := varTranspiler(charVar2, funcNames, allVarsChars, allVarsInts)
;MsgBox, % intType

if (intType = "int_t")
{
intType := "int"
}

cppCode .= intType . " " . charVar1 . Chr(59) . "`n"
}
else
{
charVar1 := Trim(StrSplit(strVar, varAssignmentType, 1))
charVar2 := Trim(StrSplit(strVar, varAssignmentType, 2))
charVar1 := StrSplit(charVar1, " ", 1)


charVar2 := varTranspiler(charVar2, funcNames, allVarsChars, allVarsInts)
;MsgBox, % intType

if (intType = "int_t")
{
intType := "int"
}

cppCode .= intType . " " . charVar1 . " " . varAssignmentType . " " . charVar2 . Chr(59) . "`n"
}



}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = "cat ")
{
lineDone := 1
StringTrimLeft, strVar, A_LoopField, 4

strVar := Trim(strVar)

declareAvarNOvalue := 0
if (InStr(strVar, " := "))
{
varAssignmentType := "="
}
else if (InStr(strVar, " += "))
{
varAssignmentType := "+="
}
else if (InStr(strVar, " .= "))
{
varAssignmentType := "+="
}
else if (InStr(strVar, " -= "))
{
varAssignmentType := "-="
}
else if (InStr(strVar, " *= "))
{
varAssignmentType := "*="
}
else if (InStr(strVar, " /= "))
{
varAssignmentType := "/="
}
else
{
declareAvarNOvalue := 1
}

if (declareAvarNOvalue = 1)
{
nameOfVar1 := Trim(StrSplit(strVar, " ", 1))
nameOfVarSplit := StrSplit(strVar, " ", 2)
nameOfVar2 := Trim(StrSplit(strVar, str(nameOfVarSplit), 2))
nameOfVar2 := varTranspiler(nameOfVar2, funcNames, allVarsChars, allVarsInts)

nameOfVar11 := Trim(StrSplit(nameOfVar1, "%", 1))
nameOfVar12 := Trim(StrSplit(nameOfVar1, "%", 2))
nameOfVar1 := "variables[" . Chr(34) . nameOfVar11 . Chr(34) . " + std::string(variables[" . Chr(34) . nameOfVar12 . Chr(34) . "])]"

cppCode .= nameOfVar1 . Chr(59) . "`n"
}
else
{
nameOfVar1 := Trim(StrSplit(strVar, " ", 1))
nameOfVarSplit := StrSplit(strVar, " ", 2)
nameOfVar2 := Trim(StrSplit(strVar, str(nameOfVarSplit), 2))
nameOfVar2 := varTranspiler(nameOfVar2, funcNames, allVarsChars, allVarsInts)

nameOfVar11 := Trim(StrSplit(nameOfVar1, "%", 1))
nameOfVar12 := Trim(StrSplit(nameOfVar1, "%", 2))
nameOfVar1 := "variables[" . Chr(34) . nameOfVar11 . Chr(34) . " + std::string(variables[" . Chr(34) . nameOfVar12 . Chr(34) . "])]"

cppCode .= nameOfVar1 . " " . varAssignmentType . " " . nameOfVar2 . Chr(59) . "`n"
}

lineDone := 1
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss1)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 3) = StrLower(CheckIFandElsesss2)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = StrLower(CheckIFandElsesss3)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss4)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss5)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = StrLower(CheckIFandElsesss6)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = StrLower(CheckIFandElsesss7)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss8))
{
lineDone := 1

if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss1))
{
CheckIFandElsesssNum := 4
CheckIFandElsesssNumNum := 1
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 3) = StrLower(CheckIFandElsesss2))
{
CheckIFandElsesssNum := 3
CheckIFandElsesssNumNum := 2
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = StrLower(CheckIFandElsesss3))
{
CheckIFandElsesssNum := 5
CheckIFandElsesssNumNum := 3
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss4))
{
CheckIFandElsesssNum := 4
CheckIFandElsesssNumNum := 4
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss5))
{
CheckIFandElsesssNum := 9
CheckIFandElsesssNumNum := 5
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = StrLower(CheckIFandElsesss6))
{
CheckIFandElsesssNum := 8
CheckIFandElsesssNumNum := 6
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = StrLower(CheckIFandElsesss7))
{
CheckIFandElsesssNum := 10
CheckIFandElsesssNumNum := 7
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss8))
{
CheckIFandElsesssNum := 9
CheckIFandElsesssNumNum := 8
}

StringTrimLeft, str123, A_LoopField, CheckIFandElsesssNum

str123 := StrReplace(str123, "(", " ( ")
str123 := StrReplace(str123, ")", " ) ")
str123 := StrReplace(str123, "!", " ! ")


str123 := CheckIFandElsesss%CheckIFandElsesssNumNum% . Chr(32) . varTranspiler(str123, funcNames, allVarsChars, allVarsInts)

str123 := StrReplace(str123, "( ", "(")
str123 := StrReplace(str123, " )", ")")
str123 := StrReplace(str123, " ! ", "!")



str123 := StrReplace(str123, "std::string()", "")
str123 := StrReplace(str123, "if " . Chr(40) . Chr(32), "if " . Chr(40))

str123 := StrReplace(str123, "!==", "!=")

out123 := str123

cppCode .= out123 . "`n"
}
else if (StrLower(A_LoopField) = "loop")
{
; infinity loops
haveWeEverUsedAloop := 1
lineDone := 1

var1 := "for (int A" . Chr(95) . "Index" . str(AindexcharLength) . " = 1;; A" . Chr(95) . "Index" . str(AindexcharLength) . "++)"
nothing := ""
AindexcharLengthStr := nothing . str(AindexcharLength) . nothing


pycodeAcurlyBraceAddSomeVrasFixNL := 1

pycodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength) . "`n"
pycodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength)
AindexcharLength++
cppCode .= pycodeLoopfixa1 . "`n" . var1 . "`n"

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 6) = "loop, ") && (SubStr(Trim(StrLower(A_LoopField)), 1, 8) != "loop, % ") && (SubStr(Trim(StrLower(A_LoopField)), 1, 7) != "loop % ") && (SubStr(Trim(StrLower(A_LoopField)), 1, 11) != StrLower("Loop, Parse"))
{



str123 := A_LoopField
;MsgBox, % str123


StringTrimLeft, out2, str123, 6

;MsgBox % out2

;MsgBox, % out2
out2 := Trim(out2)
lineDone := 1

myVar := out2
lineYGI := varTranspiler(myVar, funcNames, allVarsChars, allVarsInts)
line := lineYGI
haveWeEverUsedAloop := 1
;MsgBox, % line

var1 := "for (int A" . Chr(95) . "Index" . str(AindexcharLength) . " = 1; A" . Chr(95) . "Index" . str(AindexcharLength) . "<= " . line . "; ++A" . Chr(95) . "Index" . str(AindexcharLength) . ")"
nothing := ""
AindexcharLengthStr := nothing . str(AindexcharLength) . nothing


pycodeAcurlyBraceAddSomeVrasFixNL := 1

pycodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength) . "`n"
pycodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength)
AindexcharLength++

cppCode .= pycodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = "loop, % ")
{
str123 := A_LoopField
;MsgBox, % str123
lineDone := 1

StringTrimLeft, out2, str123, 8

;MsgBox % out2

;MsgBox, % out2
out2 := Trim(out2)


myVar := out2
lineYGI := varTranspiler(myVar, funcNames, allVarsChars, allVarsInts)
line := lineYGI

;MsgBox, % line
var1 := "for A" . Chr(95) . "Index" . str(AindexcharLength) . " in range(1, " . line . " + 1):"
nothing := ""
AindexcharLengthStr := nothing . str(AindexcharLength) . nothing


pycodeAcurlyBraceAddSomeVrasFixNL := 1
haveWeEverUsedAloop := 1
pycodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength) . "`n"
pycodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength)
AindexcharLength++
cppCode .= pycodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 13) = StrLower("Loop, Parse, "))
{
;std::vector<std::string> items = LoopParseFunc(variables["var1"], " ");
lineDone := 1
var1 := A_LoopField

var1 := Trim(var1)
StringTrimLeft, var1, var1, 13

line1 := Trim(StrSplit(var1, ",", 1))

line1 := varTranspiler(line1, funcNames, allVarsChars, allVarsInts)
line2 := ""
line3 := ""
itemsOut := ""
line2 := Trim(StrSplit(var1, ",", 2))
line3 := Trim(StrSplit(var1, ",", 3))



if (InStr(var1, Chr(96) . ","))
{
line2 := Chr(34) . "," . Chr(34)
itemsOut := "std::vector<std::string> items" . str(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}
else
{



if (line2 = "") && (line3 = "")
{
; nothing so only each char
itemsOut := "std::vector<std::string> items" . str(AindexcharLength) . " = LoopParseFunc(" . line1 . ");"
}

if (line2 != "") && (line3 = "")
{
if (InStr(line2, Chr(96)))
{
line2 := Chr(34) . line2 . Chr(34)
}
itemsOut := "std::vector<std::string> items" . str(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}

if (line2 != "") && (line3 != "")
{
if (InStr(line2, Chr(96)))
{
line2 := Chr(34) . line2 . Chr(34)
}
if (InStr(line3, Chr(96)))
{
line3 := Chr(34) . line3 . Chr(34)
}

itemsOut := "std::vector<std::string> items" . str(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ");"
}



itemsOut := StrReplace(itemsOut, Chr(96), Chr(92))



}

;for (size_t A_Index1 = 0; A_Index1 < items.size(); A_Index1++)
var1out := itemsOut . "`n" . "for (size_t A" . Chr(95) . "Index" . str(AindexcharLength) . " = 1; A" . Chr(95) . "Index" . str(AindexcharLength) . " < items" . str(AindexcharLength) . ".size(); A" . Chr(95) . "Index" . str(AindexcharLength) . "++)"



nothing := ""
AindexcharLengthStr := nothing . str(AindexcharLength) . nothing


theFixTextLoopLP := "std::string A" . Chr(95) . "LoopField" . str(AindexcharLength) . " = items" . str(AindexcharLength) . "[A" . Chr(95) . "Index" . str(AindexcharLength) . "];"

pycodeAcurlyBraceAddSomeVrasFixLP := 1
haveWeEverUsedAloop := 1
pycodeLoopfixa .= "lp|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength) . "`n"
pycodeLoopfixa1 := "lp|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength)
AindexcharLength++
cppCode .= pycodeLoopfixa1 . "`n" . var1out . "`n"
lineDone := 1
}
else if (StrLower(A_LoopField) = "break")
{
cppCode .= A_LoopField . ";`n"
lineDone := 1
}
else if (StrLower(A_LoopField) = "continue")
{
cppCode .= A_LoopField . ";`n"
lineDone := 1
}
else if (StrLower(A_LoopField) = "return") or (SubStr(Trim(StrLower(A_LoopField)), 1, 7) = "return ")
{
if (StrLower(A_LoopField) = "return")
{
cppCode .= A_LoopField . ";`n"
lineDone := 1
}
else
{
StringTrimLeft, varTranspiledReturn, A_LoopField, 7
varTranspiledReturn := varTranspiler(varTranspiledReturn, funcNames, allVarsChars, allVarsInts)
cppCode .= "return " . varTranspiledReturn . ";`n"
lineDone := 1
}
}
else if (InStr(A_LoopField, " := ")) or (InStr(A_LoopField, " .= ")) or (InStr(A_LoopField, " += ")) or (InStr(A_LoopField, " -= ")) or (InStr(A_LoopField, " *= ")) or (InStr(A_LoopField, " /= ")) && (lineDone = 0)
{
lineDone := 1
strVar := A_LoopField
strVar := Trim(strVar)

if (InStr(strVar, " := "))
{
varAssignmentType := "="
}
if (InStr(strVar, " += "))
{
varAssignmentType := "+="
}
if (InStr(strVar, " .= "))
{
varAssignmentType := "+="
}
if (InStr(strVar, " -= "))
{
varAssignmentType := "-="
}
if (InStr(strVar, " *= "))
{
varAssignmentType := "*="
}
if (InStr(strVar, " /= "))
{
varAssignmentType := "/="
}

nameOfVar1 := Trim(StrSplit(strVar, " ", 1))
nameOfVarSplit := StrSplit(strVar, " ", 2)
nameOfVar2 := Trim(StrSplit(strVar, str(nameOfVarSplit), 2))
nameOfVar2 := varTranspiler(nameOfVar2, funcNames, allVarsChars, allVarsInts)

cppCode .= nameOfVar1  . " " . varAssignmentType . " " . nameOfVar2 . Chr(59) . "`n"

}
else
{
; this is THE else

if (removeNextCurlyBraceCpp != 1)
{
removeNextCurlyBraceCpp := 0

if (skipLeftCuleyForFuncPLS != 1)
{
if (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(125))
{
cppCode .= Chr(125) . "`n"
}
else
{
if (pycodeAcurlyBraceAddSomeVrasFixLP = 1) && (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(123))
{
pycodeAcurlyBraceAddSomeVrasFixLP := 0


cppCode .= A_LoopField . "`n" . theFixTextLoopLP . "`n"
}
else
{
if (pycodeAcurlyBraceAddSomeVrasFixNL = 1) && (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(123))
{
pycodeAcurlyBraceAddSomeVrasFixNL := 0
cppCode .= A_LoopField . "`n" . theFixTextLoopNL . "`n"
}
else
{
cppCode .= A_LoopField . "`n"
}
}
}
}
else
{
skipLeftCuleyForFuncPLS := 0
}

}
else
{

if (Trim(A_LoopField) = "{") && (removeNextCurlyBraceCpp = 1)
{
removeNextCurlyBraceCpp := 0
}
else
{
cppCode .= A_LoopField . "`n"
}


}
}

}

StringTrimRight, cppCode, cppCode, 1

; cat int var% int num1% := cat str string% int num1%













































;s

if (haveWeEverUsedAloop = 1)
{

StringTrimRight, pycodeLoopfixa, pycodeLoopfixa, 1

;OutputDebug, |%pycodeLoopfixa%|
AIndexLoopCurlyFix := 1
Loop, Parse, pycodeLoopfixa, `n, `r
{



str123 := A_LoopField
fixLoopLokingFor := A_LoopField
fixLoopLokingForfound := 1
out1 := StrSplit(str123 ,"|" , 1)
out2 := StrSplit(str123 ,"|" , 3)
;OutputDebug, |%out1%|
;OutputDebug, |%out2%|



wasAtanyIfsElseAddAIndexLoopCurlyFix := 0


if (out1 = "nl")
{


inTarget := 0
insideBracket := 0
netsedCurly := 0
eldLoopNestedBADlol := 0
readyToEnd := 0
endBracketDOntPutThere := 0
dontSaveStr := 0
weAreDoneHereCurly := 0
DeleayOneCuzOfLoopParse := 0
fixLoopLokingForNum := 0
insdeAnestedLoopBAD := 0
foundTheTopLoop := 0
out4758686d86d86d86578991a%AIndexLoopCurlyFix% := ""
Loop, Parse, cppCode, `n, `r
{
;MsgBox, dsfgsdefgesrdg1
;MsgBox, |%A_LoopField%|`n|%fixLoopLokingFor%|


if (InStr(A_LoopField, fixLoopLokingFor)) && (insdeAnestedLoopBAD != 1)
{
fixLoopLokingForNum := 1

;MsgBox, do we came here 1
}

if (InStr(A_LoopField, "for ")) && (weAreDoneHereCurly != 1) && (insdeAnestedLoopBAD != 1) && (fixLoopLokingForNum = 1)
{

s := StrSplit(A_LoopField ,"A" . Chr(95) . "Index", 2)
out1z := s


s := StrSplit(out1z, " ", 1)
out1z := Trim(s)


;MsgBox, % out1z

;MsgBox, do we came here 2
fixLoopLokingForNum := 0
foundTheTopLoop++
  inTarget := 1
	;MsgBox, % A_LoopField
	dontSaveStr := 1

	ALoopField := A_LoopField

	;ALoopField := StrReplace(ALoopField, "for (/* Loop parse */", "for (/* Loop parse */ /* From AHK */")
DeleayOneCuzOfLoopParse := 1
	out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"
}

if (inTarget = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
insideBracket := 1
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly++
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(125))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly--
readyToEnd := 1
}

if (InStr(A_LoopField, "for ")) && (insdeAnestedLoopBAD != 1) && (foundTheTopLoop >= 2)
{
insdeAnestedLoopBAD := 1
insideBracket1 := 0
netsedCurly1 := 0
}
if (inTarget = 1)
{
foundTheTopLoop++
}
if (insdeAnestedLoopBAD = 1)
{



if (InStr(A_LoopField, Chr(123)))
{
insideBracket1 := 1
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(123)))
{
netsedCurly1++
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(125)))
{
netsedCurly1--
readyToEnd1 := 1
}


if (InStr(A_LoopField, Chr(125))) && (readyToEnd1 = 1) && (netsedCurly1 = 0) && (insideBracket = 1)
{
;MsgBox, % A_LoopField
eldLoopNestedBADlol := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}

out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}


if (inTarget = 1) && (dontSaveStr != 1) && (fixLoopLokingForNum != 1) && (insdeAnestedLoopBAD != 1)
{

ALoopField := A_LoopField




; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "A" . Chr(95) . "Index(?:\\d+)?", "A" . Chr(95) . "Index" . out1z)



;ALoopField := StrReplace(ALoopField, "A_LoopField", "A_LoopField" . AIndexLoopCurlyFix)


out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"

}


if (inTarget = 1) && (InStr(A_LoopField, Chr(125))) && (readyToEnd = 1) && (netsedCurly = 0) && (weAreDoneHereCurly = 0) && (dontSaveStr != 1) && (insdeAnestedLoopBAD != 1)
{
;MsgBox, % A_LoopField
weAreDoneHereCurly := 1
inTarget := 0
endBracketDOntPutThere := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}
dontSaveStr := 0

if (inTarget != 1) && (endBracketDOntPutThere != 1) && (insdeAnestedLoopBAD != 1)
{
out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}
endBracketDOntPutThere := 0

if (eldLoopNestedBADlol = 1)
{
 insdeAnestedLoopBAD := 0
}


}
strstysrstsytTRIMHELP := out4758686d86d86d86578991a%AIndexLoopCurlyFix%
StringTrimRight, strstysrstsytTRIMHELP, strstysrstsytTRIMHELP, 1
;MsgBox, % out4758686d86d86d86578991a%AIndexLoopCurlyFix%


cppCode := strstysrstsytTRIMHELP

;MsgBox, % jsCode
wasAtanyIfsElseAddAIndexLoopCurlyFix := 1
}
else
{


inTarget := 0
insideBracket := 0
netsedCurly := 0
eldLoopNestedBADlol := 0
readyToEnd := 0
endBracketDOntPutThere := 0
dontSaveStr := 0
weAreDoneHereCurly := 0
DeleayOneCuzOfLoopParse := 0
fixLoopLokingForNum := 0
insdeAnestedLoopBAD := 0
foundTheTopLoop := 0
out4758686d86d86d86578991a%AIndexLoopCurlyFix% := ""
Loop, Parse, cppCode, `n, `r
{

if (InStr(A_LoopField , fixLoopLokingFor)) && (insdeAnestedLoopBAD != 1)
{
fixLoopLokingForNum := 1
;MsgBox, do we came here 3
}

if (InStr(A_LoopField , "for ")) && (weAreDoneHereCurly != 1) && (insdeAnestedLoopBAD != 1) && (fixLoopLokingForNum = 1)
{


s := StrSplit(A_LoopField ,"A" . Chr(95) . "Index", 2)
out1z := s

s := StrSplit(out1z, " ", 1)
out1z := Trim(s)

;MsgBox, % out1z

fixLoopLokingForNum := 0
;MsgBox, do we came here 4
foundTheTopLoop++
  inTarget := 1
	;MsgBox, % A_LoopField
	dontSaveStr := 1

	ALoopField := A_LoopField

	;ALoopField := StrReplace(ALoopField, "for (/* Loop parse */", "for (/* Loop parse */ /* From AHK */")
DeleayOneCuzOfLoopParse := 1
	out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"
}

if (inTarget = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
insideBracket := 1
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly++
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(125))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly--
readyToEnd := 1
}

if (InStr(A_LoopField, "for ")) && (insdeAnestedLoopBAD != 1) && (foundTheTopLoop >= 2)
{
insdeAnestedLoopBAD := 1
insideBracket1 := 0
netsedCurly1 := 0
}
if (inTarget = 1)
{
foundTheTopLoop++
}
if (insdeAnestedLoopBAD = 1)
{



if (InStr(A_LoopField, Chr(123)))
{
insideBracket1 := 1
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(123)))
{
netsedCurly1++
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(125)))
{
netsedCurly1--
readyToEnd1 := 1
}


if (InStr(A_LoopField, Chr(125))) && (readyToEnd1 = 1) && (netsedCurly1 = 0) && (insideBracket = 1)
{
;MsgBox, % A_LoopField
eldLoopNestedBADlol := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}


out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}


if (inTarget = 1) && (dontSaveStr != 1) && (fixLoopLokingForNum != 1) && (insdeAnestedLoopBAD != 1)
{

ALoopField := A_LoopField


; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "A" . Chr(95) . "Index(?:\\d+)?", "A" . Chr(95) . "Index" . out1z)
; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "A" . Chr(95) . "LoopField(?:\\d+)?", "A" . Chr(95) . "LoopField" . out1z)





out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"

}


if (inTarget = 1) && (InStr(A_LoopField, Chr(125))) && (readyToEnd = 1) && (netsedCurly = 0) && (weAreDoneHereCurly = 0) && (dontSaveStr != 1) && (insdeAnestedLoopBAD != 1)
{
;MsgBox, % A_LoopField
weAreDoneHereCurly := 1
inTarget := 0
endBracketDOntPutThere := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}
dontSaveStr := 0

if (inTarget != 1) && (endBracketDOntPutThere != 1) && (insdeAnestedLoopBAD != 1)
{
out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}
endBracketDOntPutThere := 0

if (eldLoopNestedBADlol = 1)
{
 insdeAnestedLoopBAD := 0
}


}

strstysrstsytTRIMHELP := out4758686d86d86d86578991a%AIndexLoopCurlyFix%
StringTrimRight, strstysrstsytTRIMHELP, strstysrstsytTRIMHELP, 1
;MsgBox, % out4758686d86d86d86578991a%AIndexLoopCurlyFix%


cppCode := strstysrstsytTRIMHELP

;MsgBox, % jsCode
wasAtanyIfsElseAddAIndexLoopCurlyFix := 1
}

if (wasAtanyIfsElseAddAIndexLoopCurlyFix = 1)
{
AIndexLoopCurlyFix++
wasAtanyIfsElseAddAIndexLoopCurlyFix := 0
}
}


out4758686d86dgt8r754444444 := ""
hold := 0
Loop, Parse, cppCode, `n, `r
{
ignore := 0
if (InStr(A_LoopField, "for "))
{
if (hold = 1) && (holdText = A_LoopField)
{
ignore := 1
}
else
{
holdText := A_LoopField
hold := 1
}
}

if (!(ignore))
{
out4758686d86dgt8r754444444 .= A_LoopField . "`n"
}
}

StringTrimRight, out4758686d86dgt8r754444444, out4758686d86dgt8r754444444, 1
cppCode := out4758686d86dgt8r754444444


}




pyCodeOut1234565432 := ""
Loop, Parse, cppCode, `n, `r
{
out := A_LoopField
if (!(InStr(out, "|itsaersdtgtgfergsdgfsegdfsedAA|")))
{
pyCodeOut1234565432 .= out . "`n"
}
}


StringTrimRight, cppCode, pyCodeOut1234565432, 1
























Loop, % theIdNumOfThe34
{
cppCode := StrReplace(cppCode, "ihuiuuhuuhtheidFor--asas-theuhturtyphoutr-" . Chr(65) . Chr(65) . str(A_Index) . Chr(65) . Chr(65), "std::string(" . theIdNumOfThe34theVar%A_Index% . ")")
}

cppCodeFixCharRemoveStd := ""
Loop, Parse, cppCode, `n, `r
{
if (SubStr(Trim(StrLower(A_LoopField)), 1, 12) = "const char* ")
{
cppCodeFixCharRemoveStd123 := A_LoopField

cppCodeFixCharRemoveStd123 := StrReplace(cppCodeFixCharRemoveStd123, "std::string(", "")
cppCodeFixCharRemoveStd123 := StrReplace(cppCodeFixCharRemoveStd123, ")", "")

cppCodeFixCharRemoveStd .= cppCodeFixCharRemoveStd123 . "`n"
}
else
{
cppCodeFixCharRemoveStd .= A_LoopField . "`n"
}
}
StringTrimRight, cppCode, cppCodeFixCharRemoveStd, 1

if (theMainFuncDec = 0)
{
upCode := "`nint main()`n{`n"
}

uperCode := "#include <iostream>`n#include <sstream>`n#include <vector>`n#include <unordered_map>`n#include <string>`n#include <any>`n#include <cstdint>`n#include <regex>`n#include <fstream>`n#include <filesystem>`n#include <cctype>`n#include <algorithm>`n#include <cmath>`n#include <limits>`n#include <chrono>`n`n// Define a map to store dynamic variables`n" . "// Create a map to hold variables`n    std::unordered_map<std::string, std::string> variables;`n"

if (InStr(cppCode, "INT(")) or (InStr(cppCode, "INT ("))
{
uperCode := uperCode . "`n// Convert std::string to int`nint INT(const std::string& str) {`n    std::istringstream iss(str);`n    int value;`n    iss >> value;`n    return value;`n}`n"
}
if (InStr(cppCode, "STR(")) or (InStr(cppCode, "STR ("))
{
uperCode := uperCode . "`n// Convert various types to std::string`nstd::string STR(int value) {`n    return std::to_string(value);`n}`n`nstd::string STR(float value) {`n    return std::to_string(value);`n}`n`nstd::string STR(double value) {`n    return std::to_string(value);`n}`n`nstd::string STR(size_t value) {`n    return std::to_string(value);`n}`n`nstd::string STR(bool value) {`n    return value ? " . Chr(34) . "1" . Chr(34) . " : " . Chr(34) . "0" . Chr(34) . ";`n}`n"
}
if (InStr(cppCode, "FLOAT(")) or (InStr(cppCode, "FLOAT ("))
{
uperCode := uperCode . "`n// Convert std::string to float`nfloat FLOAT(const std::string& str) {`n    std::istringstream iss(str);`n    float value;`n    iss >> value;`n    return value;`n}`n"
}


if (InStr(cppCode, "InStr(")) or (InStr(cppCode, "InStr ("))
{
uperCode := uperCode . "`n// Function to check if needle exists in haystack (std::string overload)`nbool InStr(const std::string& haystack, const std::string& needle) {`n    return haystack.find(needle) != std::string::npos;`n}`n"
}

if (InStr(cppCode, "LoopParseFunc("))
{
uperCode := uperCode . "`n// Function to escape special characters for regex`nstd::string escapeRegex(const std::string& str) {`n    static const std::regex specialChars{R" . Chr(34) . "([-[\]{}()*+?.,\^$|#\s])" . Chr(34) . "};`n    return std::regex_replace(str, specialChars, R" . Chr(34) . "(\$&)" . Chr(34) . ");`n}`n`n// Function to split a string based on delimiters`nstd::vector<std::string> LoopParseFunc(const std::string& var, const std::string& delimiter1 = " . Chr(34) . "" . Chr(34) . ", const std::string& delimiter2 = " . Chr(34) . "" . Chr(34) . ") {`n    std::vector<std::string> items;`n    if (delimiter1.empty() && delimiter2.empty()) {`n        // If no delimiters are provided, return a list of characters`n        for (char c : var) {`n            items.push_back(std::string(1, c));`n        }`n    } else {`n        // Escape delimiters for regex`n        std::string escapedDelimiters = escapeRegex(delimiter1 + delimiter2);`n        // Construct the regular expression pattern for splitting the string`n        std::string pattern = " . Chr(34) . "[" . Chr(34) . " + escapedDelimiters + " . Chr(34) . "]+" . Chr(34) . ";`n        std::regex regexPattern(pattern);`n        std::sregex_token_iterator iter(var.begin(), var.end(), regexPattern, -1);`n        std::sregex_token_iterator end;`n        while (iter != end) {`n            items.push_back(*iter++);`n        }`n    }`n    return items;`n}`n"
}

if (InStr(cppCode, "print(")) or (InStr(cppCode, "print ("))
{
uperCode := uperCode . "`n// Print function that converts all types to string if needed`ntemplate <typename T>`nvoid print(const T& value) {`n    if constexpr (std::is_same_v<T, std::string>) {`n        std::cout << value << std::endl;`n    } else if constexpr (std::is_same_v<T, int>) {`n        std::cout << STR(value) << std::endl;`n    } else if constexpr (std::is_same_v<T, float>) {`n        std::cout << STR(value) << std::endl;`n    } else if constexpr (std::is_same_v<T, double>) {`n        std::cout << STR(value) << std::endl;`n    } else if constexpr (std::is_same_v<T, size_t>) {`n        std::cout << STR(value) << std::endl;`n    } else if constexpr (std::is_same_v<T, bool>) {`n        std::cout << STR(value) << std::endl;`n    } else {`n        std::cout << " . Chr(34) . "Unsupported type" . Chr(34) . " << std::endl;`n    }`n}`n"
}



if (InStr(cppCode, "FileRead("))
{
uperCode := uperCode . "`nstd::string FileRead(const std::string& path) {`n    std::ifstream file;`n    std::filesystem::path full_path;`n`n    // Check if the file path is an absolute path`n    if (std::filesystem::path(path).is_absolute()) {`n        full_path = path;`n    } else {`n        // If it's not a full path, prepend the current working directory`n        full_path = std::filesystem::current_path() / path;`n    }`n`n    // Open the file`n    file.open(full_path);`n    if (!file.is_open()) {`n        throw std::runtime_error(" . Chr(34) . "Error: Could not open the file." . Chr(34) . ");`n    }`n`n    // Read the file content into a string`n    std::string content;`n    std::string line;`n    while (std::getline(file, line)) {`n        content += line + '" . Chr(92) . "n';`n    }`n`n    file.close();`n    return content;`n}`n"
}



if (InStr(cppCode, "FileAppend("))
{
uperCode := uperCode . "`nbool FileAppend(const std::string& content, const std::string& path) {`n    std::ofstream file;`n`n    // Open the file in append mode`n    file.open(path, std::ios::app);`n`n    if (!file.is_open()) {`n        std::cerr << " . Chr(34) . "Error: Could not open the file for appending." . Chr(34) . " << std::endl;`n        return false;`n    }`n`n    // Append the content to the file`n    file << content;`n`n    // Close the file`n    file.close();`n`n    return true;`n}`n"
}



if (InStr(cppCode, "FileDelete("))
{
uperCode := uperCode . "`nbool FileDelete(const std::string& path) {`n    std::filesystem::path file_path(path);`n`n    // Check if the file exists`n    if (!std::filesystem::exists(file_path)) {`n        std::cerr << " . Chr(34) . "Error: File does not exist." . Chr(34) . " << std::endl;`n        return false;`n    }`n`n    // Attempt to remove the file`n    if (!std::filesystem::remove(file_path)) {`n        std::cerr << " . Chr(34) . "Error: Failed to delete the file." . Chr(34) . " << std::endl;`n        return false;`n    }`n`n    return true;`n}`n"
}

;;;;;;;;;;;;;;;

if (InStr(cppCode, "SubStr(")) or (InStr(cppCode, "SubStr ("))
{
uperCode := uperCode . "`n// SubStr function to get a substring with optional length`nstd::string SubStr(const std::string& str, int startPos, int length = -1) {`n    std::string result;`n    size_t strLen = str.size();`n`n    // Handle negative starting positions`n    if (startPos < 0) {`n        startPos += strLen;`n        if (startPos < 0) startPos = 0;`n    } else {`n        if (startPos > static_cast<int>(strLen)) return " . Chr(34) . "" . Chr(34) . "; // Starting position beyond string length`n        startPos -= 1; // Convert to 0-based index`n    }`n`n    // Handle length`n    if (length < 0) {`n        length = strLen - startPos; // Length to end of string`n    } else if (startPos + length > static_cast<int>(strLen)) {`n        length = strLen - startPos; // Adjust length to fit within the string`n    }`n`n    // Extract substring`n    result = str.substr(startPos, length);`n    return result;`n}`n"
}

if (InStr(cppCode, "Trim(")) or (InStr(cppCode, "Trim ("))
{
uperCode := uperCode . "`n// Function to trim leading and trailing whitespace from a string`nstd::string Trim(const std::string &inputString) {`n    if (inputString.empty()) return " . Chr(34) . "" . Chr(34) . ";`n`n    size_t start = inputString.find_first_not_of(" . Chr(34) . " " . Chr(92) . "t" . Chr(92) . "n" . Chr(92) . "r" . Chr(92) . "f" . Chr(92) . "v" . Chr(34) . ");`n    size_t end = inputString.find_last_not_of(" . Chr(34) . " " . Chr(92) . "t" . Chr(92) . "n" . Chr(92) . "r" . Chr(92) . "f" . Chr(92) . "v" . Chr(34) . ");`n`n    return (start == std::string::npos) ? " . Chr(34) . "" . Chr(34) . " : inputString.substr(start, end - start + 1);`n}`n"
}

if (InStr(cppCode, "StrReplace(")) or (InStr(cppCode, "StrReplace ("))
{
uperCode := uperCode . "`n// Function to replace all occurrences of a substring with another substring`nstd::string StrReplace(const std::string &originalString, const std::string &find, const std::string &replaceWith) {`n    std::string result = originalString;`n    size_t pos = 0;`n`n    while ((pos = result.find(find, pos)) != std::string::npos) {`n        result.replace(pos, find.length(), replaceWith);`n        pos += replaceWith.length();`n    }`n`n    return result;`n}`n"
}

if (InStr(cppCode, "StringTrimLeft(")) or (InStr(cppCode, "StringTrimLeft ("))
{
uperCode := uperCode . "`n// Function to trim characters from the left of the string`nstd::string StringTrimLeft(const std::string &input, int numChars) {`n    return (numChars <= input.length()) ? input.substr(numChars) : input;`n}`n"
}

if (InStr(cppCode, "StringTrimRight(")) or (InStr(cppCode, "StringTrimRight ("))
{
uperCode := uperCode . "`n// Function to trim characters from the right of the string`nstd::string StringTrimRight(const std::string &input, int numChars) {`n    return (numChars <= input.length()) ? input.substr(0, input.length() - numChars) : input;`n}`n"
}

if (InStr(cppCode, "StrLower(")) or (InStr(cppCode, "StrLower ("))
{
uperCode := uperCode . "`n// Function to convert a string to lowercase`nstd::string StrLower(const std::string &string) {`n    std::string result = string;`n    std::transform(result.begin(), result.end(), result.begin(), ::tolower);`n    return result;`n}`n"
}

if (InStr(cppCode, "RegExReplace(")) or (InStr(cppCode, "RegExReplace ("))
{
uperCode := uperCode . "`n// Function to perform a regex replacement`nstd::string RegExReplace(const std::string &inputStr, const std::string &regexPattern, const std::string &replacement) {`n    std::regex regex(regexPattern);`n    return std::regex_replace(inputStr, regex, replacement);`n}`n"
}

if (InStr(cppCode, "StrSplit(")) or (InStr(cppCode, "StrSplit ("))
{
uperCode := uperCode . "`n// Function to split a string by a delimiter and return the nth part`nstd::string StrSplit(const std::string &inputStr, const std::string &delimiter, int num) {`n    size_t start = 0, end = 0, count = 0;`n`n    while ((end = inputStr.find(delimiter, start)) != std::string::npos) {`n        if (++count == num) {`n            return inputStr.substr(start, end - start);`n        }`n        start = end + delimiter.length();`n    }`n`n    if (count + 1 == num) {`n        return inputStr.substr(start);`n    }`n`n    return " . Chr(34) . "" . Chr(34) . ";`n}`n"
}

if (InStr(cppCode, "Chr(")) or (InStr(cppCode, "Chr ("))
{
uperCode := uperCode . "`n// Function to convert a number to a character`nstd::string Chr(int number) {`n    return (number >= 0 && number <= 0x10FFFF) ? std::string(1, static_cast<char>(number)) : " . Chr(34) . "" . Chr(34) . ";`n}`n"
}

if (InStr(cppCode, "Mod(")) or (InStr(cppCode, "Mod ("))
{
uperCode := uperCode . "`n// Custom Mod function`nint Mod(int dividend, int divisor) {`n    return dividend % divisor;`n}`n"
}

if (InStr(cppCode, "Floor(")) or (InStr(cppCode, "Floor ("))
{
uperCode := uperCode . "`ndouble Floor(double num) {`n    if (std::isnan(num)) {`n        return std::numeric_limits<double>::quiet_NaN();`n    }`n    return std::floor(num);`n}`n"
}


if (InStr(cppCode, "A_TickCount(")) or (InStr(cppCode, "A_TickCount ("))
{
uperCode := uperCode . "`nauto start_timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();`n`n// Function to calculate tick count in milliseconds`nstd::string A_TickCount() {`n    auto current_timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();`n    return std::to_string(current_timestamp - start_timestamp);`n}`n"
}







downCode := "`nreturn 0;`n}"

cppCode := uperCode . upCode . cppCode . downCode

cppCode := StrReplace(cppCode, "std::string()", "")

;MsgBox, % cppCode
StringTrimRight, filePathOfCode, filePathOfCode, 4
filePathOfCode := filePathOfCode . "cpp"
FileDelete, %filePathOfCode%
FileAppend, %cppCode%, %filePathOfCode%






