; HT++

isVarAnumKindaVar(strrrrr)
{

strLettersStart := 48
Loop, 10
{
if (InStr(strrrrr, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}

return false
}

varDetect(strrrrr)
{

if (InStr(strrrrr, "-"))
{
return false
}

numFixhsidhkcjzdls := 0
Loop, Parse, strrrrr
{
numFixhsidhkcjzdls++
}
numFixhsidhkcjzdls22 := 0
Loop, Parse, strrrrr
{
if (A_LoopField = Chr(48)) or (A_LoopField = Chr(49)) or (A_LoopField = Chr(50)) or (A_LoopField = Chr(51)) or (A_LoopField = Chr(52)) or (A_LoopField = Chr(53)) or (A_LoopField = Chr(54)) or (A_LoopField = Chr(55)) or (A_LoopField = Chr(56)) or (A_LoopField = Chr(57)) or (A_LoopField = Chr(46))
{
numFixhsidhkcjzdls22++
}
}

if (numFixhsidhkcjzdls = numFixhsidhkcjzdls22)
{
return false
}

strLettersStart := 97
Loop, 26
{
if (InStr(strrrrr, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}


strLettersStart := 65
Loop, 26
{
if (InStr(strrrrr, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}


strLettersStart := 48
Loop, 10
{
if (InStr(strrrrr, Chr(strLettersStart)))
{
return true
}
strLettersStart++
}

if (InStr(strrrrr, Chr(95)))
{
return true
}

if (InStr(strrrrr, Chr(37)))
{
return true
}

return false
}


isVarAfuncOrWhat(varInVarTranspiler, funcNames, allVarsChars, allVarsInts)
{

if (InStr(varInVarTranspiler, "%"))
{

nameOfVarr11 := Trim(StrSplit(varInVarTranspiler, "%", 1))
nameOfVarr12 := Trim(StrSplit(varInVarTranspiler, "%", 2))
nameOfVarr111 := "variables[" . Chr(34) . nameOfVarr11 . Chr(34) . " + convertToStr(variables[" . Chr(34) . nameOfVarr12 . Chr(34) . "])]"

return nameOfVarr111
}

Loop, Parse, allVarsChars, `n ,`r
{
if (Trim(varInVarTranspiler) = Trim(A_LoopField))
{
return "std::string(" . varInVarTranspiler . ")"
}
}

Loop, Parse, allVarsInts, `n ,`r
{
if (Trim(varInVarTranspiler) = Trim(A_LoopField))
{
return "std::any(" . varInVarTranspiler . ")"
}
}

Loop, Parse, funcNames, "|"
{
if (Trim(varInVarTranspiler) = Trim(A_LoopField))
{
return varInVarTranspiler
}
}



if (varDetect(varInVarTranspiler))
{
return "variables[" . Chr(34) . varInVarTranspiler . Chr(34) . "]"
}

if (isVarAnumKindaVar(varInVarTranspiler))
{
return varInVarTranspiler
}


if (varInVarTranspiler = ".")
{
return "+"
}

if (varInVarTranspiler = "=")
{
return "=="
}

if (varInVarTranspiler = "or")
{
return "||"
}

if (varInVarTranspiler = "and")
{
return "&&"
}

return varInVarTranspiler

}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

varTranspiler(var123, funcNames, allVarsChars, allVarsInts)
{
var123out := ""

lastType := ""
typeMode := 0
Loop, Parse, var123, " "
{

if (A_LoopField = "int") or (A_LoopField = "str")
{
typeMode := 1
lastType := Trim(A_LoopField)
}
if (A_LoopField != "int") and (A_LoopField != "str") and (typeMode = 1)
{

varInVarTranspiler := Trim(A_LoopField)
varOut2out := isVarAfuncOrWhat(varInVarTranspiler, funcNames, allVarsChars, allVarsInts)

if (lastType = "int")
{
varOut2out := "convertToInt(" . varOut2out . ")"
}
if (lastType = "str")
{
varOut2out := "convertToStr(" . varOut2out . ")"
}

var123out .= str(varOut2out) . " "

typeMode := 0
}
else if (A_LoopField != "int") and (A_LoopField != "str") and (typeMode = 0)
{
varInVarTranspiler := Trim(A_LoopField)
varOut2out := isVarAfuncOrWhat(varInVarTranspiler, funcNames, allVarsChars, allVarsInts)

var123out .= str(varOut2out) . " "
}


}

StringTrimRight, var123out, var123out, 1
return var123out
} ; end of func





CheckIFandElsesss1 := "if ("
CheckIFandElsesss2 := "if("
CheckIFandElsesss3 := "if !("
CheckIFandElsesss4 := "if!("
CheckIFandElsesss5 := "else if ("
CheckIFandElsesss6 := "else if("
CheckIFandElsesss7 := "else if !("
CheckIFandElsesss8 := "else if!("
CheckIFandElsesssNum := 0
onceImportTime := 0
weUseRandomAtLeastOnce := 0
weEverUseVars := ""
haveWeEverUsedAloop := 0
usedLib := ""
putEndPointFlask1Up := ""
putEndPointFlask2Down := ""
AindexcharLength := 1
pycodeAcurlyBraceAddSomeVrasFixNL := 0
pycodeAcurlyBraceAddSomeVrasFixLP := 0
pycodeLoopfixa := ""
out := ""
HTpyCodeD1 := ""
skipLeftCuleyForFuncPLS := 0
eavbnsalvbaslv := 0


params := GetParams()
Loop, Parse, params, `n, `r
{
if (A_Index = 1)
{
MsgBox, % A_LoopField
code := FileRead(A_LoopField)
}
if (A_Index = 2)
{
MsgBox, % A_LoopField
}
}
MsgBox, % code

codeTrimBeggining := ""
Loop, Parse, code, `n, `r
{
codeTrimBeggining .= Trim(A_LoopField) . "`n"
}
StringTrimRight, code, codeTrimBeggining, 1


HTpyCodeOUT754754 := ""
areWEinSome34sNum := 0
theIdNumOfThe34 := 0

Loop, Parse, code
{
theIdNumOfThe34theVar%A_Index% := Chr(34)
}

Loop, Parse, code
{
if (A_LoopField = Chr(34))
{
areWEinSome34sNum++
}


if (areWEinSome34sNum = 1)
{



if (A_LoopField != Chr(34))
{
if (A_LoopField = Chr(96))
{
theIdNumOfThe34theVar%theIdNumOfThe34% .= Chr(92)
}
else
{
theIdNumOfThe34theVar%theIdNumOfThe34% .= A_LoopField
}
}
else
{
theIdNumOfThe34++
HTpyCodeOUT754754 .= "ihuiuuhuuhtheidFor--asas-theuhturtyphoutr-" . Chr(65) . Chr(65) . str(theIdNumOfThe34) . Chr(65) . Chr(65)
}

}


if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0)
{
if (A_LoopField != Chr(34))
{
HTpyCodeOUT754754 .= A_LoopField
}

areWEinSome34sNum := 0
}



}
code := HTpyCodeOUT754754

Loop, % theIdNumOfThe34
{
theIdNumOfThe34theVar%A_Index% .= Chr(34)
}



allVarsChars := ""
allVarsInts := ""
funcNames := "InStr|convertToStr|convertToInt"

cppCode := ""
Loop, Parse, code, `n, `r
{


if (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = "msgbox, % ")
{
StringTrimLeft, msgboxCode, A_LoopField, 10

msgboxCode := varTranspiler(msgboxCode, funcNames, allVarsChars, allVarsInts)

cppCode .= "print(" . msgboxCode . ");" . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = "msgbox, ")
{
StringTrimLeft, msgboxCode, A_LoopField, 8



cppCode .= "print(std::string(" . Chr(34) . msgboxCode . Chr(34) . "));" . "`n"
}
else if (SubStr(A_LoopField, -1) = "++")
{
str123 := Trim(A_LoopField)
StringTrimRight, str123, str123, 2

out := "variables[" . Chr(34) . str123 . Chr(34) . "] = convertToInt(variables[" . Chr(34) . str123 . Chr(34) . "]) + 1;"

cppCode .= out . "`n"
}
else if (SubStr(A_LoopField, -1) = "--")
{
str123 := Trim(A_LoopField)
StringTrimRight, str123, str123, 2

out := "variables[" . Chr(34) . str123 . Chr(34) . "] = convertToInt(variables[" . Chr(34) . str123 . Chr(34) . "]) - 1;"
cppCode .= out . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = "fileread, ")
{
StringTrimLeft, filereadCommand, A_LoopField, 10
filereadCommand1varname := StrSplit(filereadCommand, ", ", 1)
filereadCommand2path := StrSplit(filereadCommand, ", ", 2)

filereadCommand2path := StrReplace(filereadCommand2path, "\\", "\\\\")

cppCode .= "variables[" . Chr(34) . filereadCommand1varname . Chr(34) . "] = FileRead(" . Chr(34) . filereadCommand2path . Chr(34) . ");`n"

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 12) = "fileappend, ")
{
StringTrimLeft, fileAppendCommand, A_LoopField, 12
fileAppendCommand1varname := StrSplit(fileAppendCommand, ", ", 1)
fileAppendCommand2path := StrSplit(fileAppendCommand, ", ", 2)

fileAppendCommand2path := StrReplace(fileAppendCommand2path, "\\", "\\\\")

fileAppendCommand1varname := varTranspiler(fileAppendCommand1varname, funcNames, allVarsChars, allVarsInts)

cppCode .= "FileAppend(" . fileAppendCommand1varname . ", " . Chr(34) . fileAppendCommand2path . Chr(34) . ");`n"

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 12) = "filedelete, ")
{
StringTrimLeft, fileDeleteCommand, A_LoopField, 12

fileDeleteCommand2path := StrSplit(fileDeleteCommand, ", ", 1)

fileDeleteCommand2path := StrReplace(fileDeleteCommand2path, "\\", "\\\\")


cppCode .= "FileDelete(" . Chr(34) . fileDeleteCommand2path . Chr(34) . ");`n"

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = "int ")
{
StringTrimLeft, intVar, A_LoopField, 4
intVar := Trim(intVar)

if (InStr(intVar, " := "))
{
varAssignmentType := "="
}
if (InStr(intVar, " += "))
{
varAssignmentType := "+="
}
if (InStr(intVar, " .= "))
{
varAssignmentType := "+="
}
if (InStr(intVar, " -= "))
{
varAssignmentType := "-="
}
if (InStr(intVar, " *= "))
{
varAssignmentType := "*="
}
if (InStr(intVar, " /= "))
{
varAssignmentType := "/="
}

nameOfVar1 := Trim(StrSplit(intVar, " ", 1))
nameOfVarSplit := Trim(StrSplit(intVar, " ", 2))
nameOfVar2 := Trim(StrSplit(intVar, nameOfVarSplit, 2))
nameOfVar2 := varTranspiler(nameOfVar2, funcNames, allVarsChars, allVarsInts)

cppCode .= "variables[" . Chr(34) . nameOfVar1 . Chr(34) . "]" . " " . varAssignmentType . " " . nameOfVar2 . Chr(59) . "`n"

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = "str ")
{
StringTrimLeft, strVar, A_LoopField, 4
strVar := Trim(strVar)

if (InStr(strVar, " := "))
{
varAssignmentType := "="
}
if (InStr(strVar, " += "))
{
varAssignmentType := "+="
}
if (InStr(strVar, " .= "))
{
varAssignmentType := "+="
}
if (InStr(strVar, " -= "))
{
varAssignmentType := "-="
}
if (InStr(strVar, " *= "))
{
varAssignmentType := "*="
}
if (InStr(strVar, " /= "))
{
varAssignmentType := "/="
}

nameOfVar1 := Trim(StrSplit(strVar, " ", 1))
nameOfVarSplit := Trim(StrSplit(strVar, " ", 2))
nameOfVar2 := Trim(StrSplit(strVar, nameOfVarSplit, 2))
nameOfVar2 := varTranspiler(nameOfVar2, funcNames, allVarsChars, allVarsInts)

cppCode .= "variables[" . Chr(34) . nameOfVar1 . Chr(34) . "]" . " " . varAssignmentType . " " . nameOfVar2 . Chr(59) . "`n"

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = "char ")
{
StringTrimLeft, varName123Temp, A_LoopField, 5
varName := StrSplit(varName123Temp, "[", 1)
allVarsChars .= Trim(varName) . "`n"


StringTrimLeft, strVar, A_LoopField, 5
strVar := Trim(strVar)

if (InStr(strVar, " := "))
{
varAssignmentTypeSplit := " := "
varAssignmentType := "="
}
if (InStr(strVar, " += "))
{
varAssignmentTypeSplit := " += "
varAssignmentType := "+="
}
if (InStr(strVar, " .= "))
{
varAssignmentTypeSplit := " .= "
varAssignmentType := "+="
}
if (InStr(strVar, " -= "))
{
varAssignmentTypeSplit := " -= "
varAssignmentType := "-="
}
if (InStr(strVar, " *= "))
{
varAssignmentTypeSplit := " *= "
varAssignmentType := "*="
}
if (InStr(strVar, " /= "))
{
varAssignmentTypeSplit := " /= "
varAssignmentType := "/="
}

charVar1 := Trim(StrSplit(strVar, varAssignmentTypeSplit, 1))
charVar2 := Trim(StrSplit(strVar, varAssignmentTypeSplit, 2))


cppCode .= "char " . charVar1 . " " . varAssignmentType . " " . charVar2 . Chr(59) . "`n"

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = "int8 ") or (SubStr(Trim(StrLower(A_LoopField)), 1, 6) = "int16 ") or (SubStr(Trim(StrLower(A_LoopField)), 1, 6) = "int32 ") or (SubStr(Trim(StrLower(A_LoopField)), 1, 6) = "int64 ")
{

if (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = "int8 ")
{
StringTrimLeft, varName123Temp, A_LoopField, 5
}
else
{
StringTrimLeft, varName123Temp, A_LoopField, 6
}

intType := Trim(StrSplit(A_LoopField, " ", 1)) . "_t"


varName := StrSplit(varName123Temp, " ", 1)

allVarsInts .= varName . "`n"

if (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = "int8 ")
{
StringTrimLeft, strVar, A_LoopField, 5
}
else
{
StringTrimLeft, strVar, A_LoopField, 6
}
strVar := Trim(strVar)

if (InStr(strVar, " := "))
{
varAssignmentTypeSplit := " := "
varAssignmentType := "="
}
if (InStr(strVar, " += "))
{
varAssignmentTypeSplit := " += "
varAssignmentType := "+="
}
if (InStr(strVar, " .= "))
{
varAssignmentTypeSplit := " .= "
varAssignmentType := "+="
}
if (InStr(strVar, " -= "))
{
varAssignmentTypeSplit := " -= "
varAssignmentType := "-="
}
if (InStr(strVar, " *= "))
{
varAssignmentTypeSplit := " *= "
varAssignmentType := "*="
}
if (InStr(strVar, " /= "))
{
varAssignmentTypeSplit := " /= "
varAssignmentType := "/="
}

charVar1 := Trim(StrSplit(strVar, varAssignmentTypeSplit, 1))
charVar2 := Trim(StrSplit(strVar, varAssignmentTypeSplit, 2))
charVar1 := StrSplit(charVar1, " ", 1)

cppCode .= intType . " " . charVar1 . " " . varAssignmentType . " " . charVar2 . Chr(59) . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = "cat ")
{

StringTrimLeft, strVar, A_LoopField, 4

strVar := Trim(strVar)

if (InStr(strVar, " := "))
{
varAssignmentType := "="
}
if (InStr(strVar, " += "))
{
varAssignmentType := "+="
}
if (InStr(strVar, " .= "))
{
varAssignmentType := "+="
}
if (InStr(strVar, " -= "))
{
varAssignmentType := "-="
}
if (InStr(strVar, " *= "))
{
varAssignmentType := "*="
}
if (InStr(strVar, " /= "))
{
varAssignmentType := "/="
}

nameOfVar1 := Trim(StrSplit(strVar, " ", 1))
nameOfVarSplit := Trim(StrSplit(strVar, " ", 2))
nameOfVar2 := Trim(StrSplit(strVar, nameOfVarSplit, 2))
nameOfVar2 := varTranspiler(nameOfVar2, funcNames, allVarsChars, allVarsInts)

nameOfVar11 := Trim(StrSplit(nameOfVar1, "%", 1))
nameOfVar12 := Trim(StrSplit(nameOfVar1, "%", 2))
nameOfVar1 := "variables[" . Chr(34) . nameOfVar11 . Chr(34) . " + convertToStr(variables[" . Chr(34) . nameOfVar12 . Chr(34) . "])]"

cppCode .= nameOfVar1 . " " . varAssignmentType . " " . nameOfVar2 . Chr(59) . "`n"

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss1)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 3) = StrLower(CheckIFandElsesss2)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = StrLower(CheckIFandElsesss3)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss4)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss5)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = StrLower(CheckIFandElsesss6)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = StrLower(CheckIFandElsesss7)) or (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss8))
{


if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss1))
{
CheckIFandElsesssNum := 4
CheckIFandElsesssNumNum := 1
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 3) = StrLower(CheckIFandElsesss2))
{
CheckIFandElsesssNum := 3
CheckIFandElsesssNumNum := 2
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = StrLower(CheckIFandElsesss3))
{
CheckIFandElsesssNum := 5
CheckIFandElsesssNumNum := 3
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 4) = StrLower(CheckIFandElsesss4))
{
CheckIFandElsesssNum := 4
CheckIFandElsesssNumNum := 4
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss5))
{
CheckIFandElsesssNum := 9
CheckIFandElsesssNumNum := 5
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = StrLower(CheckIFandElsesss6))
{
CheckIFandElsesssNum := 8
CheckIFandElsesssNumNum := 6
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 10) = StrLower(CheckIFandElsesss7))
{
CheckIFandElsesssNum := 10
CheckIFandElsesssNumNum := 7
}
if (SubStr(Trim(StrLower(A_LoopField)), 1, 9) = StrLower(CheckIFandElsesss8))
{
CheckIFandElsesssNum := 9
CheckIFandElsesssNumNum := 8
}

StringTrimLeft, str123, A_LoopField, CheckIFandElsesssNum

str123 := StrReplace(str123, "(", " ( ")
str123 := StrReplace(str123, ")", " ) ")
str123 := StrReplace(str123, "!", " ! ")


str123 := CheckIFandElsesss%CheckIFandElsesssNumNum% . Chr(32) . varTranspiler(str123, funcNames, allVarsChars, allVarsInts)

str123 := StrReplace(str123, "( ", "(")
str123 := StrReplace(str123, " )", ")")
str123 := StrReplace(str123, " ! ", "!")



str123 := StrReplace(str123, "std::string()", "")
str123 := StrReplace(str123, "if " . Chr(40) . Chr(32), "if " . Chr(40))



out123 := str123

cppCode .= out123 . "`n"
}
else if (StrLower(A_LoopField) = "loop")
{
; infinity loops
haveWeEverUsedAloop := 1
lineDone := 1

var1 := "for (int A" . Chr(95) . "Index" . str(AindexcharLength) . " = 1;; A" . Chr(95) . "Index" . str(AindexcharLength) . "++)"
nothing := ""
AindexcharLengthStr := nothing . str(AindexcharLength) . nothing
theFixTextLoopNL := "variables[" . Chr(34) . "A" . Chr(95) . "Index" . str(AindexcharLength) . Chr(34) . "] = A" . Chr(95) . "Index" . str(AindexcharLength) . ";"

pycodeAcurlyBraceAddSomeVrasFixNL := 1

pycodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength) . "`n"
pycodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength)
AindexcharLength++
cppCode .= pycodeLoopfixa1 . "`n" . var1 . "`n"

}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 6) = "loop, ") && (SubStr(Trim(StrLower(A_LoopField)), 1, 8) != "loop, % ") && (SubStr(Trim(StrLower(A_LoopField)), 1, 7) != "loop % ") && (SubStr(Trim(StrLower(A_LoopField)), 1, 11) != StrLower("Loop, Parse"))
{



str123 := A_LoopField
;MsgBox, % str123


StringTrimLeft, out2, str123, 6

;MsgBox % out2

;MsgBox, % out2
out2 := Trim(out2)


myVar := out2
lineYGI := varTranspiler(myVar, funcNames, allVarsChars, allVarsInts)
line := lineYGI
haveWeEverUsedAloop := 1
;MsgBox, % line

var1 := "for (int A" . Chr(95) . "Index" . str(AindexcharLength) . " = 1; A" . Chr(95) . "Index" . str(AindexcharLength) . "<= " . line ."; ++A" . Chr(95) . "Index" . str(AindexcharLength) . ")"
nothing := ""
AindexcharLengthStr := nothing . str(AindexcharLength) . nothing
theFixTextLoopNL := "variables[" . Chr(34) . "A" . Chr(95) . "Index" . str(AindexcharLength) . Chr(34) . "] = A" . Chr(95) . "Index" . str(AindexcharLength) . ";"

pycodeAcurlyBraceAddSomeVrasFixNL := 1

pycodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength) . "`n"
pycodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength)
AindexcharLength++

cppCode .= pycodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 8) = "loop, % ")
{
str123 := A_LoopField
;MsgBox, % str123


StringTrimLeft, out2, str123, 8

;MsgBox % out2

;MsgBox, % out2
out2 := Trim(out2)


myVar := out2
lineYGI := varTranspiler(myVar, funcNames, allVarsChars, allVarsInts)
line := lineYGI

;MsgBox, % line
var1 := "for A" . Chr(95) . "Index" . str(AindexcharLength) . " in range(1, " . line . " + 1):"
nothing := ""
AindexcharLengthStr := nothing . str(AindexcharLength) . nothing
theFixTextLoopNL := "variables[" . Chr(34) . "A" . Chr(95) . "Index" . str(AindexcharLength) . Chr(34) . "] = A" . Chr(95) . "Index" . str(AindexcharLength) . ";"

pycodeAcurlyBraceAddSomeVrasFixNL := 1
haveWeEverUsedAloop := 1
pycodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength) . "`n"
pycodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength)
AindexcharLength++
cppCode .= pycodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 13) = StrLower("Loop, Parse, "))
{
;std::vector<std::string> items = LoopParseFunc(variables["var1"], " ");

var1 := A_LoopField

var1 := Trim(var1)
StringTrimLeft, var1, var1, 13

line1 := Trim(StrSplit(var1, ",", 1))

line1 := varTranspiler(line1, funcNames, allVarsChars, allVarsInts)
line2 := ""
line3 := ""
itemsOut := ""
line2 := Trim(StrSplit(var1, ",", 2))
line3 := Trim(StrSplit(var1, ",", 3))



if (InStr(var1, Chr(96) . ","))
{
line2 := Chr(34) . "," . Chr(34)
itemsOut := "std::vector<std::string> items" . str(AindexcharLength) . " = LoopParseFunc(convertToStr(" . line1 . "), " . line2 . ");"
}
else
{



if (line2 = "") && (line3 = "")
{
; nothing so only each char
itemsOut := "std::vector<std::string> items" . str(AindexcharLength) . " = LoopParseFunc(convertToStr(" . line1 . "));"
}

if (line2 != "") && (line3 = "")
{
if (InStr(line2, Chr(96)))
{
line2 := Chr(34) . line2 . Chr(34)
}
itemsOut := "std::vector<std::string> items" . str(AindexcharLength) . " = LoopParseFunc(convertToStr(" . line1 . "), " . line2 . ");"
}

if (line2 != "") && (line3 != "")
{
if (InStr(line2, Chr(96)))
{
line2 := Chr(34) . line2 . Chr(34)
}
if (InStr(line3, Chr(96)))
{
line3 := Chr(34) . line3 . Chr(34)
}

itemsOut := "std::vector<std::string> items" . str(AindexcharLength) . " = LoopParseFunc(convertToStr(" . line1 . "), " . line2 . ", " . line3 . ");"
}



itemsOut := StrReplace(itemsOut, Chr(96), Chr(92))



}

;for (size_t A_Index1 = 0; A_Index1 < items.size(); A_Index1++)
var1out := itemsOut . "`n" . "for (size_t A" . Chr(95) . "Index" . str(AindexcharLength) . " = 0; A" . Chr(95) . "Index" . str(AindexcharLength) . " < items" . str(AindexcharLength) . ".size(); A" . Chr(95) . "Index" . str(AindexcharLength) . "++)"



nothing := ""
AindexcharLengthStr := nothing . str(AindexcharLength) . nothing


theFixTextLoopLP := "variables[" . Chr(34) . "A" . Chr(95) . "Index" . str(AindexcharLength) . Chr(34) . "] = std::to_string(A" . Chr(95) . "Index" . str(AindexcharLength) . " + 1);" . "`n" . "variables[" . Chr(34) . "A" . Chr(95) . "LoopField" . str(AindexcharLength) . Chr(34) . "] = items" . str(AindexcharLength) . "[A" . Chr(95) . "Index" . str(AindexcharLength) . "];"

pycodeAcurlyBraceAddSomeVrasFixLP := 1
haveWeEverUsedAloop := 1
pycodeLoopfixa .= "lp|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength) . "`n"
pycodeLoopfixa1 := "lp|itsaersdtgtgfergsdgfsegdfsedAA|" . str(AindexcharLength)
AindexcharLength++
cppCode .= pycodeLoopfixa1 . "`n" . var1out . "`n"
}
else if (StrLower(A_LoopField) = "break")
{
cppCode .= A_LoopField . ";`n"
}
else
{
; this is THE else

if (skipLeftCuleyForFuncPLS != 1)
{
if (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(125))
{
cppCode .= Chr(125) . "`n"
}
else
{
if (pycodeAcurlyBraceAddSomeVrasFixLP = 1) && (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(123))
{
pycodeAcurlyBraceAddSomeVrasFixLP := 0


cppCode .= A_LoopField . "`n" . theFixTextLoopLP . "`n"
}
else
{
if (pycodeAcurlyBraceAddSomeVrasFixNL = 1) && (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(123))
{
pycodeAcurlyBraceAddSomeVrasFixNL := 0
cppCode .= A_LoopField . "`n" . theFixTextLoopNL . "`n"
}
else
{
cppCode .= A_LoopField . "`n"
}
}
}
}
else
{
skipLeftCuleyForFuncPLS := 0
}

}


}

StringTrimRight, cppCode, cppCode, 1

; cat int var% int num1% := cat str string% int num1%













































;s

if (haveWeEverUsedAloop = 1)
{

StringTrimRight, pycodeLoopfixa, pycodeLoopfixa, 1

;OutputDebug, |%pycodeLoopfixa%|
AIndexLoopCurlyFix := 1
Loop, Parse, pycodeLoopfixa, `n, `r
{



str123 := A_LoopField
fixLoopLokingFor := A_LoopField
fixLoopLokingForfound := 1
out1 := StrSplit(str123 ,"|" , 1)
out2 := StrSplit(str123 ,"|" , 3)
;OutputDebug, |%out1%|
;OutputDebug, |%out2%|



wasAtanyIfsElseAddAIndexLoopCurlyFix := 0


if (out1 = "nl")
{


inTarget := 0
insideBracket := 0
netsedCurly := 0
eldLoopNestedBADlol := 0
readyToEnd := 0
endBracketDOntPutThere := 0
dontSaveStr := 0
weAreDoneHereCurly := 0
DeleayOneCuzOfLoopParse := 0
fixLoopLokingForNum := 0
insdeAnestedLoopBAD := 0
foundTheTopLoop := 0
out4758686d86d86d86578991a%AIndexLoopCurlyFix% := ""
Loop, Parse, cppCode, `n, `r
{
;MsgBox, dsfgsdefgesrdg1
;MsgBox, |%A_LoopField%|`n|%fixLoopLokingFor%|


if (InStr(A_LoopField, fixLoopLokingFor)) && (insdeAnestedLoopBAD != 1)
{
fixLoopLokingForNum := 1

;MsgBox, do we came here 1
}

if (InStr(A_LoopField, "for ")) && (weAreDoneHereCurly != 1) && (insdeAnestedLoopBAD != 1) && (fixLoopLokingForNum = 1)
{

s := StrSplit(A_LoopField ,"A" . Chr(95) . "Index", 2)
out1z := s


s := StrSplit(out1z, " ", 1)
out1z := Trim(s)


;MsgBox, % out1z

;MsgBox, do we came here 2
fixLoopLokingForNum := 0
foundTheTopLoop++
  inTarget := 1
	;MsgBox, % A_LoopField
	dontSaveStr := 1

	ALoopField := A_LoopField

	;ALoopField := StrReplace(ALoopField, "for (/* Loop parse */", "for (/* Loop parse */ /* From AHK */")
DeleayOneCuzOfLoopParse := 1
	out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"
}

if (inTarget = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
insideBracket := 1
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly++
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(125))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly--
readyToEnd := 1
}

if (InStr(A_LoopField, "for ")) && (insdeAnestedLoopBAD != 1) && (foundTheTopLoop >= 2)
{
insdeAnestedLoopBAD := 1
insideBracket1 := 0
netsedCurly1 := 0
}
if (inTarget = 1)
{
foundTheTopLoop++
}
if (insdeAnestedLoopBAD = 1)
{



if (InStr(A_LoopField, Chr(123)))
{
insideBracket1 := 1
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(123)))
{
netsedCurly1++
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(125)))
{
netsedCurly1--
readyToEnd1 := 1
}


if (InStr(A_LoopField, Chr(125))) && (readyToEnd1 = 1) && (netsedCurly1 = 0) && (insideBracket = 1)
{
;MsgBox, % A_LoopField
eldLoopNestedBADlol := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}

out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}


if (inTarget = 1) && (dontSaveStr != 1) && (fixLoopLokingForNum != 1) && (insdeAnestedLoopBAD != 1)
{

ALoopField := A_LoopField




; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "A" . Chr(95) . "Index(?:\\d+)?", "A" . Chr(95) . "Index" . out1z)



;ALoopField := StrReplace(ALoopField, "A_LoopField", "A_LoopField" . AIndexLoopCurlyFix)


out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"

}


if (inTarget = 1) && (InStr(A_LoopField, Chr(125))) && (readyToEnd = 1) && (netsedCurly = 0) && (weAreDoneHereCurly = 0) && (dontSaveStr != 1) && (insdeAnestedLoopBAD != 1)
{
;MsgBox, % A_LoopField
weAreDoneHereCurly := 1
inTarget := 0
endBracketDOntPutThere := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}
dontSaveStr := 0

if (inTarget != 1) && (endBracketDOntPutThere != 1) && (insdeAnestedLoopBAD != 1)
{
out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}
endBracketDOntPutThere := 0

if (eldLoopNestedBADlol = 1)
{
 insdeAnestedLoopBAD := 0
}


}
strstysrstsytTRIMHELP := out4758686d86d86d86578991a%AIndexLoopCurlyFix%
StringTrimRight, strstysrstsytTRIMHELP, strstysrstsytTRIMHELP, 1
;MsgBox, % out4758686d86d86d86578991a%AIndexLoopCurlyFix%


cppCode := strstysrstsytTRIMHELP

;MsgBox, % jsCode
wasAtanyIfsElseAddAIndexLoopCurlyFix := 1
}
else
{


inTarget := 0
insideBracket := 0
netsedCurly := 0
eldLoopNestedBADlol := 0
readyToEnd := 0
endBracketDOntPutThere := 0
dontSaveStr := 0
weAreDoneHereCurly := 0
DeleayOneCuzOfLoopParse := 0
fixLoopLokingForNum := 0
insdeAnestedLoopBAD := 0
foundTheTopLoop := 0
out4758686d86d86d86578991a%AIndexLoopCurlyFix% := ""
Loop, Parse, cppCode, `n, `r
{

if (InStr(A_LoopField , fixLoopLokingFor)) && (insdeAnestedLoopBAD != 1)
{
fixLoopLokingForNum := 1
;MsgBox, do we came here 3
}

if (InStr(A_LoopField , "for ")) && (weAreDoneHereCurly != 1) && (insdeAnestedLoopBAD != 1) && (fixLoopLokingForNum = 1)
{


s := StrSplit(A_LoopField ,"A" . Chr(95) . "Index", 2)
out1z := s

s := StrSplit(out1z, " ", 1)
out1z := Trim(s)

;MsgBox, % out1z

fixLoopLokingForNum := 0
;MsgBox, do we came here 4
foundTheTopLoop++
  inTarget := 1
	;MsgBox, % A_LoopField
	dontSaveStr := 1

	ALoopField := A_LoopField

	;ALoopField := StrReplace(ALoopField, "for (/* Loop parse */", "for (/* Loop parse */ /* From AHK */")
DeleayOneCuzOfLoopParse := 1
	out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"
}

if (inTarget = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
insideBracket := 1
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly++
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(125))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly--
readyToEnd := 1
}

if (InStr(A_LoopField, "for ")) && (insdeAnestedLoopBAD != 1) && (foundTheTopLoop >= 2)
{
insdeAnestedLoopBAD := 1
insideBracket1 := 0
netsedCurly1 := 0
}
if (inTarget = 1)
{
foundTheTopLoop++
}
if (insdeAnestedLoopBAD = 1)
{



if (InStr(A_LoopField, Chr(123)))
{
insideBracket1 := 1
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(123)))
{
netsedCurly1++
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(125)))
{
netsedCurly1--
readyToEnd1 := 1
}


if (InStr(A_LoopField, Chr(125))) && (readyToEnd1 = 1) && (netsedCurly1 = 0) && (insideBracket = 1)
{
;MsgBox, % A_LoopField
eldLoopNestedBADlol := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}


out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}


if (inTarget = 1) && (dontSaveStr != 1) && (fixLoopLokingForNum != 1) && (insdeAnestedLoopBAD != 1)
{

ALoopField := A_LoopField


; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "A" . Chr(95) . "Index(?:\\d+)?", "A" . Chr(95) . "Index" . out1z)
; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "A" . Chr(95) . "LoopField(?:\\d+)?", "A" . Chr(95) . "LoopField" . out1z)





out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= ALoopField . "`n"

}


if (inTarget = 1) && (InStr(A_LoopField, Chr(125))) && (readyToEnd = 1) && (netsedCurly = 0) && (weAreDoneHereCurly = 0) && (dontSaveStr != 1) && (insdeAnestedLoopBAD != 1)
{
;MsgBox, % A_LoopField
weAreDoneHereCurly := 1
inTarget := 0
endBracketDOntPutThere := 1
;out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"
}
dontSaveStr := 0

if (inTarget != 1) && (endBracketDOntPutThere != 1) && (insdeAnestedLoopBAD != 1)
{
out4758686d86d86d86578991a%AIndexLoopCurlyFix% .= A_LoopField . "`n"

}
endBracketDOntPutThere := 0

if (eldLoopNestedBADlol = 1)
{
 insdeAnestedLoopBAD := 0
}


}

strstysrstsytTRIMHELP := out4758686d86d86d86578991a%AIndexLoopCurlyFix%
StringTrimRight, strstysrstsytTRIMHELP, strstysrstsytTRIMHELP, 1
;MsgBox, % out4758686d86d86d86578991a%AIndexLoopCurlyFix%


cppCode := strstysrstsytTRIMHELP

;MsgBox, % jsCode
wasAtanyIfsElseAddAIndexLoopCurlyFix := 1
}

if (wasAtanyIfsElseAddAIndexLoopCurlyFix = 1)
{
AIndexLoopCurlyFix++
wasAtanyIfsElseAddAIndexLoopCurlyFix := 0
}
}


out4758686d86dgt8r754444444 := ""
hold := 0
Loop, Parse, cppCode, `n, `r
{
ignore := 0
if (InStr(A_LoopField, "for "))
{
if (hold = 1) && (holdText = A_LoopField)
{
ignore := 1
}
else
{
holdText := A_LoopField
hold := 1
}
}

if (!(ignore))
{
out4758686d86dgt8r754444444 .= A_LoopField . "`n"
}
}

StringTrimRight, out4758686d86dgt8r754444444, out4758686d86dgt8r754444444, 1
cppCode := out4758686d86dgt8r754444444


}




pyCodeOut1234565432 := ""
Loop, Parse, cppCode, `n, `r
{
out := A_LoopField
if (!(InStr(out, "|itsaersdtgtgfergsdgfsegdfsedAA|")))
{
pyCodeOut1234565432 .= out . "`n"
}
}


StringTrimRight, cppCode, pyCodeOut1234565432, 1
























Loop, % theIdNumOfThe34
{
cppCode := StrReplace(cppCode, "ihuiuuhuuhtheidFor--asas-theuhturtyphoutr-" . Chr(65) . Chr(65) . str(A_Index) . Chr(65) . Chr(65), "std::string(" . theIdNumOfThe34theVar%A_Index% . ")")
}
cppCodeFixCharRemoveStd := ""
Loop, Parse, cppCode, `n, `r
{
if (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = "char ")
{
cppCodeFixCharRemoveStd123 := A_LoopField

cppCodeFixCharRemoveStd123 := StrReplace(cppCodeFixCharRemoveStd123, "std::string(", "")
cppCodeFixCharRemoveStd123 := StrReplace(cppCodeFixCharRemoveStd123, ")", "")

cppCodeFixCharRemoveStd .= cppCodeFixCharRemoveStd123 . "`n"
}
else
{
cppCodeFixCharRemoveStd .= A_LoopField . "`n"
}
}
StringTrimRight, cppCode, cppCodeFixCharRemoveStd, 1

upCode := "`nint main()`n{`n"

if (InStr(cppCode, "variables["))
{
upCode := upCode . "// Define a map to store dynamic variables`n" . "std::unordered_map<std::string, std::any> variables;`n"
}


uperCode := "#include <iostream>`n#include <sstream>`n#include <vector>`n#include <unordered_map>`n#include <string>`n#include <any>`n#include <cstdint>`n#include <regex>`n#include <fstream>`n#include <filesystem>`n"


if (InStr(cppCode, "convertToInt("))
{
uperCode := uperCode . "`n// Function to convert std::any to int`nint convertToInt(const std::any& value) {`n    if (value.type() == typeid(std::string)) {`n        try {`n            return std::stoi(std::any_cast<std::string>(value));`n        } catch (const std::invalid_argument&) {`n            return 0; // Return 0 if conversion fails`n        }`n    } else if (value.type() == typeid(int)) {`n        return std::any_cast<int>(value);`n    } else {`n        return 0; // Return 0 for other types`n    }`n}`n"
}
if (InStr(cppCode, "convertToStr("))
{
uperCode := uperCode . "`n// Function to convert std::any to std::string`nstd::string convertToStr(const std::any& value) {`n    if (value.type() == typeid(std::string)) {`n        return std::any_cast<std::string>(value);`n    } else if (value.type() == typeid(int)) {`n        return std::to_string(std::any_cast<int>(value));`n    } else if (value.type() == typeid(int8_t)) {`n        return std::to_string(static_cast<int>(std::any_cast<int8_t>(value)));`n    } else {`n        return " . Chr(34) . "" . Chr(34) . "; // Return empty string for other types`n    }`n}`n"
}


if (InStr(cppCode, "InStr("))
{
uperCode := uperCode . "`n// Function to check if needle exists in haystack (std::string overload)`nbool InStr(const std::string& haystack, const std::string& needle) {`n    return haystack.find(needle) != std::string::npos;`n}`n"
}

if (InStr(cppCode, "LoopParseFunc("))
{
uperCode := uperCode . "`n// Function to escape special characters for regex`nstd::string escapeRegex(const std::string& str) {`n    static const std::regex specialChars{R" . Chr(34) . "([-[\]{}()*+?.,\^$|#\s])" . Chr(34) . "};`n    return std::regex_replace(str, specialChars, R" . Chr(34) . "(\$&)" . Chr(34) . ");`n}`n`n// Function to split a string based on delimiters`nstd::vector<std::string> LoopParseFunc(const std::string& var, const std::string& delimiter1 = " . Chr(34) . "" . Chr(34) . ", const std::string& delimiter2 = " . Chr(34) . "" . Chr(34) . ") {`n    std::vector<std::string> items;`n    if (delimiter1.empty() && delimiter2.empty()) {`n        // If no delimiters are provided, return a list of characters`n        for (char c : var) {`n            items.push_back(std::string(1, c));`n        }`n    } else {`n        // Escape delimiters for regex`n        std::string escapedDelimiters = escapeRegex(delimiter1 + delimiter2);`n        // Construct the regular expression pattern for splitting the string`n        std::string pattern = " . Chr(34) . "[" . Chr(34) . " + escapedDelimiters + " . Chr(34) . "]+" . Chr(34) . ";`n        std::regex regexPattern(pattern);`n        std::sregex_token_iterator iter(var.begin(), var.end(), regexPattern, -1);`n        std::sregex_token_iterator end;`n        while (iter != end) {`n            items.push_back(*iter++);`n        }`n    }`n    return items;`n}`n"
}

if (InStr(cppCode, "print("))
{
uperCode := uperCode . "`n// Function to print the value stored in std::any`nvoid print(const std::any& value) {`n    if (value.has_value()) {`n        if (value.type() == typeid(std::string)) {`n            std::cout << std::any_cast<std::string>(value) << std::endl;`n        } else if (value.type() == typeid(int)) {`n            std::cout << std::any_cast<int>(value) << std::endl;`n        }`n    } else {`n        std::cout << " . Chr(34) . "Value is not set" . Chr(34) . " << std::endl;`n    }`n}`n"
}



if (InStr(cppCode, "FileRead("))
{
uperCode := uperCode . "`nstd::string FileRead(const std::string& path) {`n    std::ifstream file;`n    std::filesystem::path full_path;`n`n    // Check if the file path is an absolute path`n    if (std::filesystem::path(path).is_absolute()) {`n        full_path = path;`n    } else {`n        // If it's not a full path, prepend the current working directory`n        full_path = std::filesystem::current_path() / path;`n    }`n`n    // Open the file`n    file.open(full_path);`n    if (!file.is_open()) {`n        throw std::runtime_error(" . Chr(34) . "Error: Could not open the file." . Chr(34) . ");`n    }`n`n    // Read the file content into a string`n    std::string content;`n    std::string line;`n    while (std::getline(file, line)) {`n        content += line + '" . Chr(92) . "n';`n    }`n`n    file.close();`n    return content;`n}`n"
}



if (InStr(cppCode, "FileAppend("))
{
uperCode := uperCode . "`nbool FileAppend(const std::string& content, const std::string& path) {`n    std::ofstream file;`n`n    // Open the file in append mode`n    file.open(path, std::ios::app);`n`n    if (!file.is_open()) {`n        std::cerr << " . Chr(34) . "Error: Could not open the file for appending." . Chr(34) . " << std::endl;`n        return false;`n    }`n`n    // Append the content to the file`n    file << content;`n`n    // Close the file`n    file.close();`n`n    return true;`n}`n"
}



if (InStr(cppCode, "FileDelete("))
{
uperCode := uperCode . "`nbool FileDelete(const std::string& path) {`n    std::filesystem::path file_path(path);`n`n    // Check if the file exists`n    if (!std::filesystem::exists(file_path)) {`n        std::cerr << " . Chr(34) . "Error: File does not exist." . Chr(34) . " << std::endl;`n        return false;`n    }`n`n    // Attempt to remove the file`n    if (!std::filesystem::remove(file_path)) {`n        std::cerr << " . Chr(34) . "Error: Failed to delete the file." . Chr(34) . " << std::endl;`n        return false;`n    }`n`n    return true;`n}`n"
}








downCode := "`nreturn 0;`n}"

cppCode := uperCode . upCode . cppCode . downCode

MsgBox, % cppCode






